#ifndef RVARAGO_ABSENT_ANDTHEN_H
#define RVARAGO_ABSENT_ANDTHEN_H

#include <functional>
#include <utility>

#include "absent/support/member.h"

namespace rvarago::absent {

/***
 * Given a nullable type N<A> (i.e. optional-like object), and an unary function f: A -> N<B>:
 * - When empty: it should return a new empty nullable N<B>.
 * - When *not* empty: it should return a nullable N<B> generated by applying the unary mapping function to the input
 * nullable's value, already wrapped in a nullable N<B>.
 *
 * @param input a nullable N<A>.
 * @param mapper an unary function A -> N<B>.
 * @return a new nullable generated by mapper, possibly empty if input was also empty.
 */
template <template <typename> typename Nullable, typename UnaryFunction, typename A>
constexpr auto and_then(Nullable<A> const &input, UnaryFunction &&mapper) noexcept
    -> decltype(std::declval<UnaryFunction>()(std::declval<A>())) {
    using NullableB = decltype(mapper(std::declval<A>()));
    if (!input) {
        return NullableB{};
    }
    return std::forward<UnaryFunction>(mapper)(*input);
}

/***
 * Infix version of and_then.
 */
template <template <typename> typename Nullable, typename UnaryFunction, typename A>
constexpr auto operator>>(Nullable<A> const &input, UnaryFunction &&mapper) noexcept
    -> decltype(std::declval<UnaryFunction>()(std::declval<A>())) {
    return and_then(input, std::forward<UnaryFunction>(mapper));
}

/***
 * The same as and_then but for a member function that has to be const and parameterless.
 */
template <template <typename> typename Nullable, typename A, typename B>
constexpr auto and_then(Nullable<A> const &input, support::member_mapper<const A, Nullable<B>> mapper) noexcept
    -> Nullable<B> {
    return and_then(input, [&mapper](auto const &value) { return std::invoke(mapper, value); });
}

/***
 * Infix version of and_then for a member function.
 */
template <template <typename> typename Nullable, typename A, typename B>
constexpr auto operator>>(Nullable<A> const &input, support::member_mapper<const A, Nullable<B>> mapper) noexcept
    -> Nullable<B> {
    return and_then(input, mapper);
}

}

#endif
