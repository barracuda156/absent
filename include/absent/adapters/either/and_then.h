#ifndef RVARAGO_ABSENT_ADAPTERS_EITHER_ANDTHEN_H
#define RVARAGO_ABSENT_ADAPTERS_EITHER_ANDTHEN_H

#include <functional>
#include <utility>

#include "absent/adapters/either/either.h"
#include "absent/support/member.h"

namespace rvarago::absent::adapters::either {

/***
 * Given an either<A, E> where E is a type that represents an error, and an unary function, and an unary function f: A
 * -> either<B, E>:
 * - When in error: it should return a new either<B, E> in error wrapping the error value.
 * - When *not* in error: it should return a new either<B, E> generated by applying the unary mapping function to the
 * input value of type A, already wrapped in a either<B, E>.
 *
 * @param input an either<A, B>.
 * @param mapper an unary function A -> either<B, E>.
 * @return a new either containing the mapped value of type B, possibly in error if input was also in error.
 */
template <typename A, typename E, typename UnaryFunction>
constexpr auto and_then(types::either<A, E> const &input, UnaryFunction mapper) noexcept
    -> decltype(std::declval<UnaryFunction>()(std::declval<A>())) {
    using EitherB = decltype(mapper(std::declval<A>()));
    if (!std::holds_alternative<A>(input)) {
        return EitherB{std::get<E>(input)};
    }
    return mapper(std::get<A>(input));
}

/***
 * Infix version of and_then.
 */
template <typename A, typename E, typename UnaryFunction>
constexpr auto operator>>(types::either<A, E> const &input, UnaryFunction mapper) noexcept
    -> decltype(std::declval<UnaryFunction>()(std::declval<A>())) {
    return and_then(input, mapper);
}

/***
 * The same as and_then but for a member function that has to be const and parameterless.
 */
template <typename A, typename E, typename B>
constexpr auto and_then(types::either<A, E> const &input,
                        support::member_mapper<const A, types::either<B, E>> mapper) noexcept -> types::either<B, E> {
    return and_then(input, [&mapper](auto const &value) { return std::invoke(mapper, value); });
}

/**
 * Infix version of and_then for a member function.
 */
template <typename A, typename E, typename B>
constexpr auto operator>>(types::either<A, E> const &input,
                          support::member_mapper<const A, types::either<B, E>> mapper) noexcept -> types::either<B, E> {
    return and_then(input, mapper);
}

}

#endif
